// ═══════════════════════════════════════════════════════════
// Beautiful PDF Generator
// 2 Pages: Charts + Calculation Table
// ═══════════════════════════════════════════════════════════

import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import type { TitrationResult, ExperimentConfig, ChartConfig } from '@/types';

// ─── Colors ───
const PURPLE: [number, number, number] = [108, 99, 255];
const DARK_TEXT: [number, number, number] = [0, 0, 0]; // use pure black for exported PDF text
const GRAY_TEXT: [number, number, number] = [120, 120, 120];
const YELLOW_BG: [number, number, number] = [255, 249, 196];
const ZEBRA_GRAY: [number, number, number] = [245, 245, 245];
const WHITE: [number, number, number] = [255, 255, 255];

// ─── Page Settings ───
const PAGE_WIDTH = 210;
const PAGE_HEIGHT = 297;
const MARGIN = 15;
const CONTENT_WIDTH = PAGE_WIDTH - MARGIN * 2;
const TOTAL_PAGES = 2;

// ─── Draw Header Bar ───
function drawHeader(pdf: jsPDF, pageNum: number) {
    // Header bar สีม่วง
    pdf.setFillColor(...PURPLE);
    pdf.rect(0, 0, PAGE_WIDTH, 18, 'F');

    // Logo text
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Titration Graph Generator', MARGIN, 12);

    // Page number
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`Page ${pageNum}/${TOTAL_PAGES}`, PAGE_WIDTH - MARGIN, 12, {
        align: 'right',
    });
}

// ─── Draw Footer ───
function drawFooter(pdf: jsPDF) {
    pdf.setDrawColor(200, 200, 200);
    pdf.line(MARGIN, PAGE_HEIGHT - 15, PAGE_WIDTH - MARGIN, PAGE_HEIGHT - 15);

    pdf.setTextColor(...GRAY_TEXT);
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'italic');
    pdf.text('Generated by Titration Graph Generator', MARGIN, PAGE_HEIGHT - 10);

    // วันเวลาที่สร้าง
    const now = new Date().toLocaleString('th-TH');
    pdf.text(now, PAGE_WIDTH - MARGIN, PAGE_HEIGHT - 10, { align: 'right' });
}

// ─── Draw Rounded Box ───
function drawRoundedBox(
    pdf: jsPDF,
    x: number,
    y: number,
    w: number,
    h: number,
    options?: { fill?: boolean; shadow?: boolean }
) {
    if (options?.shadow) {
        pdf.setFillColor(230, 230, 230);
        pdf.roundedRect(x + 1, y + 1, w, h, 3, 3, 'F');
    }
    pdf.setDrawColor(200, 200, 200);
    pdf.setFillColor(255, 255, 255);
    pdf.roundedRect(x, y, w, h, 3, 3, options?.fill ? 'FD' : 'D');
}

// ─── Main Export Function ───
export async function exportPDF(
    result: TitrationResult,
    config: ExperimentConfig,
    chartConfig: ChartConfig,
    profile: { full_name: string; university: string },
    phChart: HTMLCanvasElement | string,
    dvChart: HTMLCanvasElement | string
): Promise<void> {
    const pdf = new jsPDF('p', 'mm', 'a4');

    // Try to fetch and embed a Thai-capable font from the public `/fonts` folder.
    // Place `NotoSansThai-Regular.ttf` in `public/fonts/` for this to work.
    let thaiFontEmbedded = false;
    async function embedThaiFont(): Promise<boolean> {
        try {
            const resp = await fetch('/fonts/NotoSansThai-Regular.ttf');
            if (!resp.ok) return false;
            const buf = await resp.arrayBuffer();
            // convert to base64
            const bytes = new Uint8Array(buf);
            let binary = '';
            const chunk = 0x8000;
            for (let i = 0; i < bytes.length; i += chunk) {
                binary += String.fromCharCode.apply(null, Array.from(bytes.subarray(i, i + chunk)));
            }
            const base64 = btoa(binary);
            const vfsName = 'NotoSansThai-Regular.ttf';
            (pdf as any).addFileToVFS(vfsName, base64);
            (pdf as any).addFont(vfsName, 'NotoSansThai', 'normal');
            return true;
        } catch (e) {
            console.warn('Could not embed Thai font for PDF export', e);
            return false;
        }
    }

    thaiFontEmbedded = await embedThaiFont();
    const bodyFont = thaiFontEmbedded ? 'NotoSansThai' : 'helvetica';

    // ═══════════════════════════════
    // PAGE 1
    // ═══════════════════════════════
    drawHeader(pdf, 1);
    let y = 25;

    // ── ข้อมูลการทดลอง (กรอบมุมมน) ──
    drawRoundedBox(pdf, MARGIN, y, CONTENT_WIDTH, 42, {
        fill: true,
        shadow: true,
    });

    pdf.setTextColor(...PURPLE);
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Experiment Information', MARGIN + 5, y + 8);

    pdf.setTextColor(...DARK_TEXT);
    pdf.setFontSize(10);
    // use embedded Thai-capable font for body text when available
    pdf.setFont(bodyFont, 'normal');

    const infoX = MARGIN + 8;
    const infoValX = MARGIN + 45;
    let infoY = y + 16;

    const safe = (s: any) => {
        if (s === null || s === undefined) return '-';
        try {
            // Normalize to NFKC to collapse compatibility variants
            let str = String(s).normalize('NFKC');
            // Remove common Unicode control/invisible characters (Cc, C1 controls and common zero-widths)
            // Note: Unicode property escapes may not be available when targeting older JS versions,
            // so use explicit ranges for compatibility.
            str = str.replace(/[\u0000-\u001F\u007F-\u009F\u200B\u200C\u200D\uFEFF]/g, '');
            // Trim and collapse whitespace
            str = str.replace(/\s+/g, ' ').trim();
            return str || '-';
        } catch (e) {
            // Fallback conservative cleaning for older runtimes
            const str = String(s).replace(/[\u0000-\u001F\u007F-\u009F]/g, '').replace(/\s+/g, ' ').trim();
            return str || '-';
        }
    };

    // Include time (HH:MM) along with date for clearer timestamp in the PDF
    const formattedDate = new Date().toLocaleString('th-TH-u-nu-latn', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
    });

    const info = [
        ['Experiment', `${safe(config.expName)} ${safe(config.expNo)}`],
        // Prefer config.studentName, fall back to profile.full_name when available
        ['Experimenter', safe(config.studentName) !== '-' ? safe(config.studentName) : safe(profile.full_name) || '-'],
        ['University', safe(profile.university) || '-'],
        ['Date', safe(formattedDate)],
    ];

    for (const [label, value] of info) {
        let v = safe(value);
        // ensure Date always prints; fallback to formattedDate if sanitizer returned '-'
        if (label === 'Date' && (v === '-' || !v)) {
            v = formattedDate;
        }
        // label: use helvetica bold for consistent label weight
        pdf.setFont('helvetica', 'bold');
        pdf.text(`${label}:`, infoX, infoY);
        // value: use body font (Thai-capable when embedded)
        pdf.setFont(bodyFont, 'normal');
        // allow wrapping for long values
        const maxW = CONTENT_WIDTH - (infoValX - MARGIN) - 8;
        pdf.text(v, infoValX, infoY, { maxWidth: maxW });
        // estimate line height for wrapped text
        const lines = pdf.splitTextToSize(v, maxW);
        infoY += Math.max(6, lines.length * 5 + 2);
    }

    y += 48;

    // ── กราฟ 1: pH vs Volume ──
    pdf.setTextColor(...DARK_TEXT);
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'bold');
    pdf.text(`Graph 1: pH vs ${config.xLabel}`, MARGIN, y);
    y += 4;

    // กรอบกราฟ (มุมมน + เงา)
    const graphHeight = 85;
    drawRoundedBox(pdf, MARGIN, y, CONTENT_WIDTH, graphHeight, { shadow: true });

    // ใส่กราฟ
    const phImage = typeof phChart === 'string' ? phChart : phChart.toDataURL('image/png', 1.0);
    pdf.addImage(phImage, 'PNG', MARGIN + 2, y + 2, CONTENT_WIDTH - 4, graphHeight - 4);
    y += graphHeight + 6;

    // ── กราฟ 2: ΔpH/ΔV vs Volume ──
    pdf.setTextColor(...DARK_TEXT);
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'bold');
    pdf.text(`Graph 2: dpH/dV vs ${config.xLabel}`, MARGIN, y);
    y += 4;

    drawRoundedBox(pdf, MARGIN, y, CONTENT_WIDTH, graphHeight, { shadow: true });

    const dvImage = typeof dvChart === 'string' ? dvChart : dvChart.toDataURL('image/png', 1.0);
    pdf.addImage(dvImage, 'PNG', MARGIN + 2, y + 2, CONTENT_WIDTH - 4, graphHeight - 4);

    drawFooter(pdf);

    // ═══════════════════════════════
    // PAGE 2
    // ═══════════════════════════════
    pdf.addPage();
    drawHeader(pdf, 2);
    y = 25;

    // ── ตาราง ──
    pdf.setTextColor(...DARK_TEXT);
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Calculation Results', MARGIN, y);
    y += 4;

    // สร้างข้อมูลตาราง
    const tableBody: (string | number)[][] = [];

    // แถวแรก (ไม่มี ΔpH, ΔV, ΔpH/ΔV)
    tableBody.push([
        result.volume[0].toFixed(2),
        result.pH[0].toFixed(2),
        '—',
        '—',
        '—',
    ]);

    // แถวที่เหลือ
    for (let i = 0; i < result.dPHdV.length; i++) {
        tableBody.push([
            result.volume[i + 1].toFixed(2),
            result.pH[i + 1].toFixed(2),
            result.deltaPH[i].toFixed(2),
            result.deltaV[i].toFixed(2),
            result.dPHdV[i].toFixed(2),
        ]);
    }

    autoTable(pdf, {
        startY: y,
        head: [['Volume (mL)', 'pH', 'ΔpH', 'ΔV', 'ΔpH/ΔV']],
        body: tableBody,
        theme: 'grid',
        headStyles: {
            fillColor: PURPLE,
            textColor: [255, 255, 255],
            fontStyle: 'bold',
            halign: 'center',
            fontSize: 10,
            font: bodyFont,
        },
        bodyStyles: {
            halign: 'center',
            fontSize: 9,
            textColor: DARK_TEXT,
            font: bodyFont,
        },
        alternateRowStyles: {
            fillColor: ZEBRA_GRAY,
        },
        // Highlight End Point row
        didParseCell: (data) => {
            // eqIndex + 1 because first row is "—" row
            if (data.section === 'body' && data.row.index === result.eqIndex + 1) {
                data.cell.styles.fillColor = YELLOW_BG;
                data.cell.styles.fontStyle = 'bold';
                data.cell.styles.textColor = [180, 130, 0];
            }
        },
        margin: { left: MARGIN, right: MARGIN },
    });

    y = (pdf as any).lastAutoTable.finalY + 8;

    // Footer and finish (summary removed per user request)
    drawFooter(pdf);

    // ═══ Save ═══
    const fileName = `${config.expName}_${config.expNo}_report.pdf`.replace(
        /\s+/g,
        '_'
    );
    pdf.save(fileName);
}
